#pragma config(Sensor, S1,     Lbump,          sensorTouch)
#pragma config(Sensor, S2,     Rbump,          sensorTouch)
#pragma config(Sensor, S3,     Sonar,          sensorSONAR)
#pragma config(Motor,  motorA,          LMotor,        tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          RMotor,        tmotorNXT, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define DEFAULT_SPEED 50
#define MIN_SPEED 10
#define MAX_DIFF 10
#define MAX_CHANGE 10
#define MIN_CHANGE 4
#define MAX_SPEED 65
#define STOP_DIST 8

int lSpeed_chase;
int rSpeed_chase;
int lSpeed_fear;
int rSpeed_fear;
int lSpeed_drink;
int rSpeed_drink;
int lSpeed_feeding;
int rSpeed_feeding;
int distNew;

int cornerSpeed;
int driveSpeed;

bool isScared = false;
bool leftWhite = false;
bool rightWhite = false;

bool isFeeding = false;
int hunger = 100;
bool foundFood = false;
bool isRecovering = false;
int fear = 50;

bool seeObj = false;

//turn off course some arbitrary random amount, then go straight, then
//turn back to the original orientation. An "S" bend gets performed, effectively.
void drunkTurn() {
	int LSpeed;
	int RSpeed;
	//get direction and duration
	int Dir = random(100) % 2;

	//time is for turning duration, time2 is for the forward duration.
	int turnDuration = (random(100)%5+1) * 350;
	int forwardDuration = (random(100)%3+1) * 100;

	//initial turn off-course
	if(Dir) {
		LSpeed = cornerSpeed;
		RSpeed = driveSpeed;
		} else {
		LSpeed = driveSpeed;
		RSpeed = cornerSpeed;
	}
	lSpeed_drink = LSpeed;
	rSpeed_drink = RSpeed;
	//move straight
	wait1Msec(turnDuration);
	LSpeed = driveSpeed;
	RSpeed = driveSpeed;
	lSpeed_drink = LSpeed;
	rSpeed_drink = RSpeed;
	wait1Msec(forwardDuration);

	//Turn back to the forward position
	if(Dir) {
		LSpeed = driveSpeed;
		RSpeed = cornerSpeed;
		} else {
		LSpeed = cornerSpeed;
		RSpeed = driveSpeed;
	}
	lSpeed_drink = LSpeed;
	rSpeed_drink = RSpeed;
	wait1Msec(turnDuration);
	//set mototrs back to normal speed, straight ahead.
	LSpeed = driveSpeed;
	RSpeed = driveSpeed;
	lSpeed_drink = LSpeed;
	rSpeed_drink = RSpeed;
}

void reverse(int direction) {
	int counter = 0;
	bool prev_state;
	bool cur_state;
	int range;
	//right was the last one to hit
	lSpeed_feeding = 0;
	rSpeed_feeding = 0;
	sleep(100);
	lSpeed_feeding = -1 * (DEFAULT_SPEED / 5);
	rSpeed_feeding = DEFAULT_SPEED;
	eraseDisplay();
	displayBigTextLine(4, "reverse start");
	range = 2;
	prev_state = leftWhite;
	if(leftWhite) {
		range = 3;
		} else {
		range = 2;
	}
	while(counter < range && !(rightWhite && leftWhite)) {
		sleep(10);
		cur_state = leftWhite;
		if(prev_state != cur_state) {
			prev_state = cur_state;
			counter++;
		}
	}
	displayBigTextLine(4, "reverse end");

}
void turnLeft() {
	lSpeed_feeding = -10;
	rSpeed_feeding = DEFAULT_SPEED / 2 + 9;
	while(!rightWhite) {
		sleep(5);
	}
	lSpeed_feeding = 0;
	rSpeed_feeding = 0;
	sleep(20);
}

/*
* Function to turn the robot right by applying more power to the left wheel
*/
void turnRight() {
	lSpeed_feeding = DEFAULT_SPEED / 2 + 9;
	rSpeed_feeding = -10;
	while(!leftWhite) {
		sleep(5);
	}
	lSpeed_feeding = 0;
	rSpeed_feeding = 0;
	sleep(20);
}
task followGradient() {
	int begin = 0;
	int end = 0;
	int dif = 0;
	int dir = -1;
	int counter = 0;
	int consec_white = 0;
	while(true) {
		if(!rightWhite && leftWhite) {//right sensor
			dir = 1;
			} else if(!leftWhite && rightWhite) {//left sensor
			dir = 2;
			} else if(!leftWhite && !rightWhite) { //both sensors triggered, hard reverse
			if(dir == 3) {
				reverse(dir);
			}
			dir = 0;
			lSpeed_feeding = DEFAULT_SPEED / 2 - 4;
			rSpeed_feeding = DEFAULT_SPEED / 2 - 4;
			sleep(10);
			}	else if(leftWhite && rightWhite) {
			if(dir == 3 && !isFeeding && foundFood) {
				consec_white += (nSysTime - consec_white);
				if(consec_white > 2000) {
					playSound(soundBeepBeep);
					isFeeding = true;
				}
				} else {
				consec_white = nSysTime;
			}
			dir = 3;
			lSpeed_feeding = DEFAULT_SPEED / 2 - 4;
			rSpeed_feeding = DEFAULT_SPEED / 2 - 4;
			sleep(10);
		}
		if(dir == 1 || dir == 2) {
			dif = end - begin;
			//eraseDisplay();
			//displayBigTextLine(4, "counter%d", counter);
			begin = nSysTime;
			if(dir == 1) {
				turnLeft();
				} else {
				turnRight();
			}
			end = nSysTime;
			if((end - begin) > dif) {
				//eraseDisplay();
				//displayBigTextLine(4, "counter%d", counter);
				counter++;
			}
			if(counter >= 3) {
				reverse(dir);
				counter = 0;
			}
		}

	}
}



/*
*	Returns an amount that is randomly between MIN_CHANGE and
*	MAX_CHANGE and is positive or negative (with 50% chance of either).
*/
int getSpeedChange() {
	int speed_change = MAX_CHANGE - abs(random(MIN_CHANGE));
	if(abs(random(100))%2){
		speed_change = speed_change * -1;
	}
	return speed_change;
}

/*
*	Changes the current speed of one motor by the variable change.
*	If the speed goes below a certain value it is reset to the MIN_SPEED.
*/
int setNewSpeed(int speed, int change) {
	speed += change;
	if(speed < MIN_SPEED)
		speed = MIN_SPEED;
	return speed;
}
task recv_data(){
	int num;
	ubyte incoming[3];
	ubyte ACK[1] = {1};
	nxtEnableHSPort();
	nxtHS_Mode = hsRawMode;
	nxtSetHSBaudRate(9600);
	wait1Msec(2000);
	while(true){
		num = nxtGetAvailHSBytes();
		if(num==3){
			nxtReadRawHS(&incoming[0],num);
			nxtWriteRawHS(&ACK[0],1,0);
		}

		if(incoming[0] == 2)
			leftWhite = true;
		else
			leftWhite = false;
		if(incoming[1] == 2)
			rightWhite = true;
		else
			rightWhite = false;
		if(incoming[2] == 2){
			isRecovering = false;
			isScared = true;
			clearTimer(T1);
			displayBigTextLine(6, "TRUE");
		}
		else{
			displayBigTextLine(6, "FALSE");
		}
		wait1Msec(100);
	}
}

task drinky_dranky(){
	driveSpeed = DEFAULT_SPEED;
	cornerSpeed = DEFAULT_SPEED + 7;
	int speed_change;
	bool is_drive = true;
	//main stuff
	while(1) {
		// get randomized number to change speed of a motor
		speed_change = getSpeedChange();

		// alternates changing speed of motor
		if (is_drive == true){
			is_drive = false;
			driveSpeed = setNewSpeed(driveSpeed, speed_change);
			if (driveSpeed > MAX_SPEED) driveSpeed = MAX_SPEED;
			} else {
			is_drive = true;
			cornerSpeed = setNewSpeed(cornerSpeed, speed_change);
			if (cornerSpeed > MAX_SPEED) driveSpeed = MAX_SPEED;
		}
		drunkTurn();
	}
}
task hunger_task(){
	while(true){
		if(isFeeding){
			hunger++;
			sleep(1200);
			}else{
			hunger--;
			if(hunger==0){
				playSound(soundDownwardTones);
				sleep(1000);
				stopAllTasks();
			}
			sleep(2400);
		}
	}
}

task recover_fear(){
	clearTimer(T1);
	while(true){
		if(isScared){
			clearTimer(T1);
			isRecovering = false;
		}
		if(time1[T1]>60000){
			isRecovering = true;
		}
		while(fear<50 && isRecovering){
			fear++;
			sleep(3600);
		}
	}
}

task escape_task(){
	while(true){
		if(isScared && fear>0){
			fear=fear-10;

			// back up
			rSpeed_fear = -50;
			lSpeed_fear = -50;

			sleep(1000);

			//Turn rand dir. Run away!!
			rSpeed_fear = -50;//need rand
			lSpeed_fear = 50;//need rand

			sleep(1000);

			rSpeed_fear = 50 + fear;
			lSpeed_fear = 50 + fear;

			sleep(fear*80); //MIGHT NEED TO FIX
			isScared = false;
		}
	}
}

task sonar_task() {
	int distCur,distPri;
	while(1) {
		displayBigTextLine(0, "%d", distNew);
		distCur = SensorValue(Sonar);
		distNew = distCur + .7* (distPri - distCur);
		distPri = distNew;
		if(distNew<100){
			seeObj = true;
		}
	}
}

task chase_task(){
	while(true) {
		if(distNew<=STOP_DIST){
			lSpeed_chase = 0;
			rSpeed_chase = 0;
			playSound(soundBeepBeep);
			sleep(4000);
			rSpeed_chase = -50;
			lSpeed_chase = -50;
			sleep(500);
			lSpeed_chase = 50;
			sleep(500);
			seeObj = false;
		}
		else if(distNew>150){
			seeObj = false;
		}
		else if(distNew>100){
			lSpeed_chase = 100;
			rSpeed_chase = 100;
		}
		else{
			lSpeed_chase = distNew;
			rSpeed_chase = distNew;
		}
	}
}

task main () {
	//initialization
	int right_bumper, left_bumper;
	int randTemp;
	startTask(recv_data);
	startTask(drinky_dranky);
	startTask(hunger_task);
	startTask(recover_fear);
	startTask(escape_task);
	startTask(sonar_task);
	startTask(followGradient);
	startTask(chase_task);
	while(true){
		//death state checked in hunger task for repsponsiveness
		left_bumper = SensorValue(Lbump);
		right_bumper = SensorValue(Rbump);
		if(left_bumper || right_bumper){
			isScared = false;
			isFeeding = false;
			foundFood= false;
			if(left_bumper){
				if(right_bumper){
					playTone(2400, 100);
					motor[RMotor] = -1*DEFAULT_SPEED;
					motor[LMotor] = -1*DEFAULT_SPEED;
					wait1Msec(500);
					motor[RMotor] = 0;
					motor[LMotor] = 0;
					wait1Msec(2000);
					//We've surrounded almost all our calls to rand() with abs(). As absurd as it
					//sounds, we sometimes would get a negative value when sampling. We don't know
					//why, it should happen, especially when using modulo. using abs() seems to
					//fix this problem though.
					randTemp = (abs(rand()%6)+2)*250;
					if(rand()%2)
					{
						motor[RMotor] = DEFAULT_SPEED;
						motor[LMotor] = -1*(DEFAULT_SPEED-25);
						wait1Msec(randTemp);
					}
					else
					{
						motor[RMotor] = -1*(DEFAULT_SPEED-25);
						motor[LMotor] = DEFAULT_SPEED;
						wait1Msec(randTemp);
					}
				}
				//only left bumped
				wait1Msec(100); //wait .1 sec

				motor[LMotor] =  0;
				motor[RMotor] = 0;
				wait1Msec(50);
				motor[RMotor] = -1*DEFAULT_SPEED; //back up half a second
				motor[LMotor] = -1*DEFAULT_SPEED;
				wait1Msec(500);
				motor[RMotor] = DEFAULT_SPEED; //turn left
				motor[LMotor] = -1*DEFAULT_SPEED;
				wait1Msec((abs(rand()%4)+3)*100); //500
			}
			else{
				motor[LMotor] = 0;
				motor[RMotor] = 0;
				wait1Msec(50);
				motor[RMotor] = -1*DEFAULT_SPEED;
				motor[LMotor] = -1*DEFAULT_SPEED;
				wait1Msec(500);
				motor[RMotor] = -1*DEFAULT_SPEED;
				motor[LMotor] = DEFAULT_SPEED;
				wait1Msec((abs(rand()%4)+3)*100); //500
			}
		}
		else if(isScared && hunger>=25 && fear>0){
			isFeeding = false;
			foundFood = false;
			motor[LMotor] = lSpeed_fear;
			motor[RMotor] = rSpeed_fear;

		}
		else if(hunger>=25 && seeObj){
			foundFood= false;
			isFeeding = false;
			motor[LMotor] = lSpeed_chase;
			motor[RMotor] = rSpeed_chase;
		}
		else if(foundFood || (hunger<50 &&(leftWhite || rightWhite))){
			isScared = false;
			foundFood= true;
			motor[LMotor] = lSpeed_feeding;
			motor[RMotor] = rSpeed_feeding;

			if(hunger>=100){
				playSound(soundBeepBeep);
				foundFood = false;
				isFeeding = false;
			}
		}
		else{
			motor[LMotor]=lSpeed_drink;
			motor[RMotor]=rSpeed_drink;
		}

		displayBigTextLine(2, "%d", fear);
		displayBigTextLine(4, "%d", hunger);
	}
}

